## 1. 洛谷 - P4913 二叉树深度

### 思路

①建立用静态数组维护的二叉树<br>
②递归计算二叉树的最大深度<br>

### 源码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 2e6+10,inf = 1e9;
int n,m;

struct Node{
    int left;
    int right;
};

Node nodes[N];
// 递归计算二叉树的最大深度
int maxDepth(int cur){
    if(cur==0) return 0;
    else return max(maxDepth(nodes[cur].left),maxDepth(nodes[cur].right))+1;
}

int main() {
    cin>>n;
    // 建树
    for(int i=1;i<n;i++){
        cin>>nodes[i].left>>nodes[i].right;
    }

    cout << maxDepth(1) << endl;

    return 0;
}
```

## 2. 洛谷 - P1364 医院设置

### 思路

二叉树问题不会高级数据结构，优先考虑暴力。（暴力不过就看题解学学吧orz）
枚举从每个节点出发，计算距离和。复杂度为O(n^2)，题目n<=100，显然很小，可以暴力。<br>
①建树<br>
②枚举从每个节点出发的距离和<br>
③利用bfs计算距离和<br>

### 源码

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 2e5+10, inf = 1e9;
int n,m,ans=inf,vis[N];

struct Node{
    int val;
    vector<int> edge; 
};

struct Node2{
    int nodeIdx;
    int depth;
};

Node nodes[N];


int cal(int cur){
    int res = 0;
    queue<Node2> q;
    q.push({cur,0});
    memset(vis, 0, sizeof vis);

    while(q.size()){
        // 获取当前节点信息
        int curNode = q.front().nodeIdx;
        int d = q.front().depth;
        q.pop();
        int val = nodes[curNode].val;

        // 标记走过节点
        if(vis[curNode]) continue;
        vis[curNode] = true;
        res += d*val;

        // 访问下一个节点
        for(int i=0;i<nodes[curNode].edge.size();i++){
            int v = nodes[curNode].edge[i];
            q.push({v,d+1});
        }
    }

    return res;
}

int main() {
    cin>>n;
    // 建树
    for(int i=1;i<=n;i++){
        int w,u,v;
        cin>>w>>u>>v;
        nodes[i].val = w;
        if(u){
            nodes[i].edge.push_back(u);
            nodes[u].edge.push_back(i);
        }
        if(v){
            nodes[i].edge.push_back(v);
            nodes[v].edge.push_back(i);
        }
    }

    // 枚举从每个节点出发的距离和
    for(int i=1;i<=n;i++){
        ans = min(ans,cal(i));
    }

    cout << ans;
    return 0;
}
```


## 3. 洛谷 - P1305 新二叉树

### 思路

本体是简单的二叉树先序遍历问题，只需用静态数组建树，并用dfs先序遍历输出各节点值即可。<br>

### 源码

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=300,inf = 1e9;
int n,m;

struct Node{
    char cur = '*'; 
    char left = '*';
    char right = '*';
};

Node nodes[N];

void dfsCout(char cur){
    if(cur == '*') return;
    // 先序遍历
    cout << cur;
    dfsCout(nodes[cur].left);
    dfsCout(nodes[cur].right);
}

int main() {
    cin>>n;
    char root;
    // 建树
    for(int i=1;i<=n;i++){
        char cur,u,v;
        cin>>cur>>u>>v;
        if(i==1) root = cur;
        nodes[cur].cur = cur;
        nodes[cur].left = u;
        nodes[cur].right = v;
    }

    dfsCout(root);
    return 0;
}   
```


## 4. 洛谷 - P1030 求先序排列

### 思路

本题是已知中序排列和后序排列反推先序排列的问题。先序排列和中序排列可以推出后序排列，中序排列和后续排列可以推出先序排列，但是先序排列和后序排列不能推出中序排列。<br>
可以先递归寻找头节点，并查找中序排列的头节点位置（利用哈希数组维护节点映射的中序位置），以此计算左右子树大小，并递归查找左右子树的头节点，查至叶子时返回头节点，即可查得头节点。<br>

### 源码

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 2e5+10, inf = 1e9;
int n,m, mp[N];
string post,in;

struct TreeNode{
    char val;
    TreeNode* left=NULL;
    TreeNode* right=NULL;
    TreeNode(int x='#'):val(x){}
};


TreeNode* f(int l1,int r1,int l2,int r2){
    if(l1>r1) return NULL;

    TreeNode* head = new TreeNode(post[r1]);
    if(l1==r1) return head;
    
    // 查找中序排列的头节点
    int k = mp[post[r1]];
    
    // 寻找左右头节点
    head->left = f(l1,l1+k-l2-1,l2,k-1);
    head->right = f(l1+k-l2,r1-1,k+1,r2);
    
    return head;
}

void dfsCout(TreeNode* head){
    if(head == NULL) return;

    cout<<head->val;
    dfsCout(head->left);
    dfsCout(head->right);
}

int main() {
    // 输入中序排列和后序排列
    cin>>in>>post;
    n = in.size();

    // 存储节点映射中序排列位置的哈希表
    for(int i=0;i<n;i++){
        mp[in[i]] = i;
    }

    // 查找头节点
    TreeNode* head = f(0,n-1,0,n-1);
    
    // dfs输出先序排列
    dfsCout(head);
    return 0;
}
```


## 5. 洛谷 - P1229 遍历问题

### 思路

观察发现只有单子结点才会造成相同的先序排列和后序排列对应两种树，所以只需要递归搜索单子结点即可。<br>

### 源码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+10, inf = 1e9;
int n,m,mp[N];
long long ans;
string pre,post;

void f(int l1,int r1,int l2,int r2){

    if(l1>=r1) return;
    else if(l1+1==r1 && pre[l1]==post[r2] && pre[l2]==post[r1]) {ans++;return;}
    
    // 查找后序排列的左子节点
    int find = mp[pre[l1+1]];

    // 只有一个子节点，先记录单子节点，再继续查找子节点的单子结点
    if(find == r2-1){
        ans++;
        f(l1+1,r1,l2,r2-1);
    }
    // 有两个子节点就分别查找连个子节点的单子节点
    else {
        f(l1+1,l1+1+find-l2,l2,find);
        f(l1+find-l2+2,r1,find+1,r2-1);
    }
}

int main() {
    cin>>pre;
    cin>>post;
    n = pre.size();
    // 节点映射后序排列的位置
    for(int i=0;i<n;i++){
        mp[post[i]] = i;
    }
    // 查找整棵树的单子结点
    f(0,n-1,0,n-1);
    cout << (1<<ans);
    return 0;
}
```


## 6. 洛谷-P2240 部分背包问题

### 思路

题目中物品可以任意切割，则只需对物品性价比进行排序，依次获取即可

### 源码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N = 2e5+10,inf = 1e9;
int n,m;
double ans;

struct arr{
    int num,val;
};
arr a[N];

signed main() {
    cin>>n>>m;
    for(int i=1;i<=n;i++) cin>>a[i].num>>a[i].val;
    
    sort(a+1,a+1+n,[](arr a,arr b){
        return (double)a.val/a.num > (double)b.val/b.num;
    });

    int res = m;
    for(int i=1;i<=n;i++){
        double t = min(a[i].num,res);
        ans+=t*a[i].val/a[i].num;
        res-=t;
        if(!res) break;
    }
    printf("%.2f",ans);
    return 0;
}
    
```

## 7. CSG - 1414 最小延迟调度问题

### 思路

按截止时间排序，截至时间相同的按持续时间排序，有先选择更加紧迫且持续时间端的任务<br>

### 源码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N = 2e5+10,inf = 1e9;
int n,m,ans;

struct arr{
    int f,d;
};
arr a[N];

signed main() {
    int t;cin>>t;
    while(t--){
        cin>>n;
        ans = 0;
        for(int i=1;i<=n;i++){
            cin>>a[i].f>>a[i].d;
        }

        sort(a+1,a+1+n,[](arr a,arr b){
            return a.d==b.d ? a.f<b.f : a.d < b.d;
        });


        int cur = 0;
        for(int i=1;i<=n;i++){
            cur+=a[i].f;
            ans = max(ans,cur-a[i].d);
        }
        cout<<ans<<'\n';
    }
    return 0;
} 
```


## 8. CSG - 1407 循环赛日程表

### 思路

观察表格可知，右下角继承左上角的安排，左下角继承右上的安排，递归访问上部分，安排下部分即可。<br>

### 源码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N = 2e3+10,inf = 1e9;
int n,m,a[N][N];

void arrange(int l,int r,int h){
    int mid = l+r>>1;
    if(l==r) return;

    // 子问题：寻找左上角和右上角进行安排
    arrange(l,mid,h/2);
    arrange(mid+1,r,h/2);
    // 把左上角的安排填充到右下角,把右上角的安排填充到左下角
    for(int i=1;i<=h;i++){
        for(int j=l;j<=r;j++){
            a[2*h+1-i][2*mid+1-j] = a[i][j]; 
        }
    }

}

signed main() {
    cin>>n;
    for(int i=1;i<=n;i++) a[1][i]=i;
    arrange(1,n,n/2);
    for(int i=1;i<=n;i++)
        for(int j=2;j<=n;j++)
            cout<<a[i][j]<<" \n"[j==n];
    return 0;
}
```


## 9. 洛谷 - P1090 合并果子

### 思路

维护一个小根堆，每次合并最小值和次小值，直到只剩一个果子即可<br>

### 源码

```cpp
#include<bits/stdc++.h>
using namespace std;

priority_queue<int,vector<int>,greater<int>> q;
const int N = 1e4+9;
int t1,t2,ans,a[N];
void solve(){
	int n;cin>>n;
	for(int i=1;i<=n;i++) {
		cin>>a[i];
		q.push(a[i]);
	}
	
	while(q.size() > 1){
		t1 = q.top();
		ans+=t1;
		q.pop();
		t2 = q.top();
		ans+=t2;
		q.pop();
		q.push(t1+t2);
	}
	cout << ans;
}

int main(){
	solve();
	return 0;
}
```


## 10. 洛谷 - P2392 kkksc03考前临时抱佛脚

### 思路

2^n枚举左脑右脑即可<br>

### 源码

```cpp
#include <bits/stdc++.h>

using namespace std;

using ll = long long;
const ll N = 1e3 + 9;

#include<bits/stdc++.h>
using namespace std;
int Left,Right,minn,ans;
int s[5];
int a[21][5];
void search(int x,int y){
	if(x > s[y]){
        minn = min(minn, max(Left, Right));
        return;
    }
    else{
        Left += a[x][y];
        search(x + 1, y);
        Left -= a[x][y];
        Right += a[x][y];
        search(x + 1, y);
        Right -= a[x][y];
        
    }
}

void solve(){
    cin >> s[1] >> s[2] >> s[3] >> s[4];
    for (int i = 1; i <= 4;i++){
        Left = 0, Right = 0;
        for (int j = 1; j <= s[i]; j++){
            cin >> a[j][i];
            }
        
        minn = 1e9 + 9;
        search(1, i);

        ans += minn;
        
    }

    cout << ans << '\n';
}

int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    solve();
    return 0;
}
```


## 11. 洛谷 - P1219 八皇后 Checker Challenge

### 思路

从第一个皇后开始依次往下搜索，不合题意的剪枝<br>

### 源码

```cpp
#include <bits/stdc++.h>

using namespace std;

using ll = long long;
const ll N = 1e3 + 9;

int a[100],b[100],c[100],d[100];
//a数组表示的是行；
//b数组表示的是列；
//c表示的是左下到右上的对角线；
//d表示的是左上到右下的对角线；
int total;//总数:记录解的总数
int n;//输入的数，即N*N的格子，全局变量，搜索中要用

void print()
{
    total++;
    if(total <=3){
        for (int i = 1; i <= n;i++){
        cout << a[i] << " ";
    }
    cout << '\n';
    }
    
}

void queen(int i){
    if(i > n){
        print();
        return;
    }
    else{
        for (int j = 1; j <= n; j++){
            if(!b[j] && !c[i + j] && !d[i - j + n]){
                a[i] = j;
                b[j] = 1;
                c[i + j] = 1;
                d[i -j + n] = 1;
                queen(i+1);
                b[j] = 0;
                c[i + j] = 0;
                d[i - j + n] = 0;

            }
            
        }
    }
}

int main()
{    
    cin>>n;//输入N*N网格，n已在全局中定义
    queen(1);//第一个皇后
    cout<<total;//输出可能的总数
    return 0;
}
```


## 12. 洛谷 - P1135 奇怪的电梯

### 思路

bfs枚举上下电梯，减去重复出现位置，队列第一次到达B楼即为答案。 <br>

### 源码

```cpp
#include <bits/stdc++.h>

using namespace std;

using ll = long long;
const ll N = 2e2 + 9;


int n, a, b, k[N], cnt[N], vis[N];

void bfs(int a) {
    queue<int> q;
    q.push(a), cnt[a] = 0;
    while (q.size()) {
        int u = q.front();

        if (u == b) {
            cout << cnt[u];
            cnt[u];
            return;
        }

        if (u + k[u] <= n && !vis[u + k[u]]) {
            int x = u + k[u];
			vis[x] = 1;
            q.push(x);
            cnt[x] = cnt[u] + 1;
        }
        if (u - k[u] >= 1 && !vis[u - k[u]]) {
            int x = u - k[u];
			vis[x] = 1;
            q.push(x);
            cnt[x] = cnt[u] + 1;
        }
        q.pop();
        if (q.front() == a) {
            cout << -1;
            return;
        }

    }
    cout << -1;
}

void solve() {
    cin >> n >> a >> b;

    for (int i = 1; i <= n; i++) {
        cin >> k[i];
    }

    bfs(a);
}

int main() {
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    solve();
    return 0;
}
```


## 13. CodeForces - 381A Sereja and Dima

### 思路

双指针模拟过程：使用 i 和 j 分别指向卡片序列的首尾，每次比较两端数值，取较大者并移动指针。  <br>
轮流计分机制：通过 cnt 计数判断当前回合归属，奇数轮（Sereja）和偶数轮（Dima）分别累加得分。  <br>
贪心策略实现：双方严格遵循取较大值的策略，直接模拟游戏规则即可得到最终得分。 <br>

### 源码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N = 2e6+10,inf = 1e9,mod = 998244353;
int n,a[N],ans1,ans2,sum;


signed main(){
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i];

    int i=1,j=n;
    int cnt = 0;
    while(i<=j){
        cnt++;
        int cur;
        if(a[i]>a[j]){
            cur=a[i];
            i++;
        } 
        else{
            cur=a[j];
            j--;
        }
        if(cnt%2) ans1+=cur;
        else ans2+=cur;
    }
    
    cout << ans1<<" "<<ans2;
    return 0;
}
```


## 14. 洛谷 - P2678 跳石头

### 思路

二分最短跳跃距离，在需要移走M个以内石头的集合里取最大解。 <br>

### 源码

```cpp
#include <bits/stdc++.h>
using namespace std;

using ll = long long;
const ll N = 1e5 + 3;

int L, n, m, a[N];

bool check(int x){
    int t = a[0], cnt = 0;
    for (int i = 1; i <= n + 1;i++){
        if(a[i]-t < x)
            cnt++;
        else
            t = a[i];
    }
    return cnt <= m;
}
int bsearch(int l, int r){
    while(l  + 1 < r){
        int mid = (l + r) >> 1;
        if(check(mid)){
            l = mid;
        }
        else{
            r = mid;
        }
    }
    return l;
}
void solve(){
    cin >> L >> n >> m;
    for (int i = 1; i <= n;i++){
        cin >> a[i];
    }
    a[n + 1] = L;
    cout << bsearch(0, L + 1);
    
}

int main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    solve();
    
    return 0;
}
```


## 15. 洛谷 - P1638 逛画展

### 思路

维护双指针，每次先驱指针前进一格，后继指针跟进，确保区间内一直有a-b幅画，记录最大值。 <br>

### 源码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<ll,ll> pll;
const ll N = 2e6+10,inf =0x3f3f3f3f;

ll n,m,cnt,ans=inf,ansi,ansj,a[N],b[N];



int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++) cin>>a[i];
    
    int i=1,j=1;
    while(cnt<m){
        if(!b[a[i]]) cnt++;
        b[a[i]]++;
        i++;
        
    }
    i--; 
    b[a[i]]--;
    for(;i<=n;i++){
        b[a[i]]++;
        while(b[a[j]] > 1){
            b[a[j]]--;
            j++;
        }
        if(i-j+1 < ans){
            ans = i-j+1;
            ansi = i;
            ansj = j;
        }

    }
    

    cout<<ansj<<" "<<ansi;    
    return 0;
}
```


## 16. 洛谷 - P8218 求区间和

### 思路

前缀和模板题。利用前缀和公式s[i]=s[i-1]+a[i]解得。 <br>

### 源码

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
ll a[100009],prefix[100009];
int main() {
	ll n; cin >> n;
	for (int i = 1; i <= n; i++) cin >> a[i];
	for (int i = 1; i <= n; i++) prefix[i] = a[i] + prefix[i - 1];

	ll m; cin >> m;
	ll l, r;
	while (m--) {
		cin >> l >> r;
		cout << prefix[r] - prefix[l-1] << endl;
	}



	return 0;
}
```


## 17. 洛谷 - P1387 最大正方形

### 思路

状态转移方程：f[i][j]=min(min(f[i-1][j],f[i][j-1]),f[i-1][j-1]) <br>

### 源码

```cpp
#include<iostream>
using namespace std;

const int N=1010;
int a[N][N],f[N][N];
int n,m,ans;
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			scanf("%d",&a[i][j]);
			
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++){
			if (a[i][j]==1) f[i][j]=min(min(f[i][j-1],f[i-1][j]),f[i-1][j-1])+1;
		}
			
			
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			ans=max(f[i][j],ans);
			
	printf("%d",ans);
}
```


## 18. 洛谷 - P8647 分巧克力

### 思路

由题意二分枚举正方形巧克力边长即可得到最大边长。 <br>

### 源码

```cpp
#include <bits/stdc++.h>
using namespace std;

using ll = long long;
const ll N = 2e5 + 3, inf = 8e18;

int H[N], W[N], n, k, ans;
bool check(int mid){
    int sum = 0;
    for (int i = 1; i <= n; i++){
        sum += (H[i] / mid) * (W[i] / mid);
    }
    if(sum >= k)
        return 1;
    else
        return 0;
}
void solve(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    cin >> n >> k;
    for (int i = 1; i <= n;i++){
        cin >> H[i] >> W[i];
    }
    int l = 1, r = 1e5 + 9;
    while(l + 1 < r){
        int mid = (l + r) / 2;
        if(check(mid)) l = mid;
        else r = mid;
    }
    cout << l << endl;
}

int main(){

    solve();
    return 0;
}
```


## 19. CSG - 1426 01背包

### 思路

01背包模板题。f[j]=max(f[j],f[j-t[i]]+v[i]);<br>

### 源码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
const int N = 100010;
int t[N],v[N],f[N];
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		scanf("%d%d",&t[i],&v[i]);
		
	for(int i=1;i<=n;i++)
		for(int j=m;j>=t[i];j--)
			f[j]=max(f[j],f[j-t[i]]+v[i]);
			
	printf("%d",f[m]);
	return 0;
}
```


## 20. CSG - 1429 最长上升子序列（需nlogn）

### 思路

这是一道典型的最长上升子序列(LIS)问题，使用动态规划结合二分查找优化，将时间复杂度从O(n²)优化到O(nlogn)。
代码通过维护单调递增的dp数组，利用lower_bound快速定位插入位置，高效地更新当前最长上升子序列。<br>


### 源码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int INF = 1e9,N = 1e6+10,mod = 1e9+7;
int n, m,b,a[N],dp[N];

signed main() {
    cin>>n>>b;
    a[1] = b;
    for(int i = 2; i <= n; i ++) {
        a[i] = 1LL * (a[i - 1] + 1) * (a[i - 1] + 1) % mod;
    }
    int cnt=0;
    for(int i=1;i<=n;i++){
        if(!cnt) dp[++cnt]=a[i]; 
        else{
            int idx = lower_bound(dp+1,dp+1+cnt,a[i])-dp;
            dp[idx]=a[i];
            cnt=max(cnt,idx);
        }
    }
    cout<<cnt<<endl;
    return 0;
}
```
